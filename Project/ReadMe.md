### C# 언어와 IL

C/C++은 특정 환경(인텔 CPU, Windows OS)에서만 실행 가능
C#은 C# 컴파일러를 통해 실행 가능한 파일을 만든다. 이 파일은 CPU와 OS에 독립적인 기계어 코드다.
중간 언어(Intermediate Language) -> C#을 컴파일러 해서 나오는 언어
IL 언어를 알 수 있으면 C# 문법에 대해 깊이 있게 알 수 있다.

### IL 파일

IL은 파일 확장자가 .il 이다.
.entrypoint는 method에 하나만 존재해야 한다.

IL 파일을 빌드하는 명령어
ilasm filename.il

exe파일을 IL 파일로 배포하는 방법
ildasm sample.exe => IL DSAM 이 실행된다.
ildasm sample.exe /out=a.txt => a.txt로 IL 코드가 생성된다.

csc test.cs // 코드 컴파일, exe 파일 빌드

### 연산자 재정의 함수의 원리

C# Operator+ => IL op_Addition으로 변환 된다.
연산자 재정의, Property, Indexer는 IL에서는 약속된 이름의 메소드로 변환된다.
단, op_Addition을 직접 만들면 에러난다. 왜냐하면 Operator+로 선언한 것이 IL에서 specialname 이름이 붙은 메서드로 변환되기 때문이다.

### MakeiIl Batch 파일

@csc %1
$ildasm /out=%~n1.il %~n1.exe
@del %~n1.exe
@del %~n1.res

### 생성자(Constructor)

참조 타입의 생성자
값 타입의 생성ㅇ자
static 생성자
Deconstructor(C# 7.0 이후)

#### 참조 타입의 객체를 생성하면

- 메모리가 먼저 0으로 초기화
- 생성자가 호출

#### 사용자가 생성자를 제공하지 않으면

- 컴파일러는 매개 변수가 없는 생성자 제공
- abstract class : porotected 생성자
- static class : 생성자가 제공되지 않는다.

### 상속과 생성자

- 파생 클래스의 객체를 생성하면 기반 클래스의 생성자가 먼저 호출된다.
- 기본적으로 인자 없는 생성자가 호출된다.
- 컴파일러는 파생 클래스의 생성자 안에서 기반 클래스의 인자 없는 생성자를 호출하는 코드가 추가된다.
- 기반 클래스의 인자 있는 생성자를 호출되게 하려면 파생 클래스에서 기반 클래스 생성자를 명시적으로 호출.
- 기반 클래스에 인자 없는 생성자가 없다면 반드시 파생 클래스에서 기반 클래스의 생성자를 명시적으로 호출해야 한다.
- 생성자를 protected에 놓으면 자신은 객체 생성 불가. 파생 클래스의 객체는 생성 가능

### 생성자와 가상함수

#### 초기화 순서

// virtual_function_in_ctor.cs에 있는 코드가 아래처럼 바뀐다.
class Derived : Base
{
public int a;
public int b;

    public Derived()
    {
        a = 100;
        Base();
        b = 100;
    }

}

#### 필드 초기화의 원리

- 초기화 순서

1. 필드 초기화
2. 기반 클래스 생성자
3. 생성자 안에 있는 초기화 코드

### 생성자 안에서는 가상함수를 사용하지 마라.

### 가상함수와 선택적 파라미터

- 가상함수에서는 Optional Parameter를 사용하지 말자.
- Optional Parameter는 컴파일 시간에 결정되고 가상함수호출은 실행 시간에 결정된다.

#### Reference Type

- 사용자가 생성자를 제공하지 않은 경우, 컴파일러는 인자가 없는 생성자를 제공한다.
- 사용자가 생성자를 제공하면, 컴파일러는 인자 없는 생성자를 제공하지 않는다.
- 객체를 만들려면 반드시 생성자가 필요.
- 사용자는 인자 없는 생성자와 인자를 가지는 생성자 모두 만들 수 있다.

#### value type

- 사용자가 인자가 없는 생성자를 만들 수 없다.
- 컴파일러가 인자가 없는 생성자를 제공하지 않는다.
- CLR "값 타입의 객체는 언제라도 생성 할 수 있도록(생성자가 없어도) 허용한다.
- 생성자가 없어도 객체를 만들 수 있다.
- 사용자는 인자를 가지는 생성자만 만들 수 있다.

### C# 언어만ㅇ의 제약

- IL 언어나 다른 .net 언어에서는 값 타입도 인자 없는 생성자를 만들 수 있다.

#### 생성자 호출과 IL 코드

- 참조 타입 : newobj
- 값 타입 : call, initobj

#### 값 타입과 필드 초기화

- 값 타입은 인자 없는 생성자를 만들 수 없다.
- 값 타입에서는 필드 초기화를 사용할 수 없다.

### value type 생성자 주의 사항

- 참조 타입의 객체 생성시 모든 멤버는 자동으로 0 또는 null로 초기화 된다. 즉, 생성자 안에서 모든 멤버를 초기화 하지 않아도 된다.
- 값 타입은 new 없이 객체 생성시 자동으로 초기화 되지 않는다. 반드시 값 타입의 생성자 안에서는 모든 멤버의 초기값을 제공해야 한다.
- Reference 타입은 상수.
- value 타입은 상수 아님.

### 타입 생성자(static constructor)

- 생성자 앞에 static이 붙는 문법
- 접근 지정자를 표기 하지 않는다. 컴파일러가 private을 자동으로 추가한다.
- 인자 없는 생성자만 만들 수 있다.
- 여러 개의 객체를 생성해도 단 한번만 호출 된다.

#### 타입 생성자의 호출

- 객체를 생성하면 static 생성자가 먼저 호출되고, instance 생성자가 호출된다.
- 여러 개의 객체를 생성해도 단 한번만 호출 된다.
- 객체를 생성하거나 정적 멤버에 접근하는 코드가 있으면 호출된다.
- 멀티 스레드 환경에도 안전하다.
- 여러 개의 타입의 static 생성자가 상호 참조 하는 코드를 작성하면 안된다.

### 필드 초기화와 생성자

#### 필드 초기값이 없는 경우

- 생성자 안에 멤버를 초기화 하는 코드가 없지만, 생성자 호출 전에 메모리가 0으로 초기화 된다.

### Deconstructor

- 객체의 필드 값을 꺼낼 때 사용
- Deconstruct라는 이름을 가지는 메소드, out parameter 사용
- 반환된 결과는 tuple로 받는다.
- 소멸자(destroy)와 혼동하지 말 것.

### System.Index

- int는 Sequence 접근을 위한 값만 보관
- System.Index는 Sequence 접근을 위한 값과 방향을 보관

#### Index 객체를 만드는 방법

1. new 사용
2. 정적 메소드 사용
3. 단축 표기법

#### 사용자 정의 타입과 Index

- 사용자 정의 컬렉션에 Index를 지원하는 방법

1. Index를 인자로 가지는 인덱서 제공
2. Length 또는 Count 속성 제공

### System.Range

- 2개의 Index를 가지고 하나의 구간을 나타내는 타입

### 패턴 매칭

- 임의의 개체가 특정 패턴을 만족하는지 조사하는 것
- r의 타입은 Rect 타입인가? r은 정사각형인가? r의 x좌표는 10인가?

type pattern matching - C# 초기 부터 지원, C# 7.0에서 기능 추가
var pattern matching - c# 7.0
const pattern matching - C# 7.0
switch expression - C# 8.0

#### type pattern matching

- is 연산자

if(객체 is 타입)
{}

- C# 7.0에서 추가된 새로운 표기법

if(객체 is 타입 변수)
{}

### Switch Expression

#### Statement(문, 문장)

- 프로그램을 구성하는 기본 요소
- C#에서 하나의 문장은 ;으로 종료된다.
- 언어에 따라 정의가 약간씩 다르다.

#### Expression(표현식)

- 대부분의 언어가 유사한 정의를 사용.
- 하나의 값으로 계산되는 식.
- 연산자와 피연산자로 구성된다.
- return을 표기하지 않아도 하나의 값으로 반환된다.

### Local Fucntion

#### Local Function

- 메소드 안에 다시 메소드를 만드는 문법
- 자신이 포함된 메소드에서만 호출할 수 있다.
- 정확한 명칭은 local function
- 오류 처리와 함수 구현부를 분리할 때 주로 사용
- Iterator 를 만들거나 비동기 메소드에서 주로 사용.

#### static local function

- non-static Local function은 자신을 포함하고 있는 메소드의 지역 변수에 접근할 수 있다.
- static Local function은 자신을 포함하고 있는 메소드의 지역변수에 접근 할 수 없다. C# 8.0에서 추가된 문법

### 스레드

#### 스레드 개념

- 코드를 실행하는 실행 흐름
- 프로세스 생성시 한 개의 스레드가 생성
- 사용자가 추가로 생성 가능

#### 스레드를 왜 만드는가?

- 응답성이 좋은 UI 프로그램
- 성능 좋은 프로그램
- CPU가 4개라면 4개의 스레드를 사용하는 것이 가장 좋다.

#### 스레드 오버 헤드

- CPU가 하나인데 2개 스레드 사용하면?
- Thread Kernel Object에 수행 기록 남김
- 2개 사용시 위 Object가 생성되고 왔다갔다하면서 실행한다.
- 이 왔다갔다하는 것을 Context Switch라고 하는데 이 비용이 만만치 않다.
- 그래서 CPU 1개당 1개의 스레드가 좋다.
- 스레드가 만들면 Thread Environment Block, stack도 생성된다.
